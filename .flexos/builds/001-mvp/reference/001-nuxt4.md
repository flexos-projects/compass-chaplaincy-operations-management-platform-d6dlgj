---
id: build-001-ref-nuxt4
title: "Nuxt 4 Reference"
description: "Key Nuxt 4 patterns, APIs, and gotchas for the COMPASS build"
type: build
subtype: reference
status: draft
sequence: 1
tags: [build, reference, nuxt]
relatesTo: ["docs/core/007-technical.md"]
createdAt: "2026-02-09T01:00:00Z"
updatedAt: "2026-02-09T01:00:00Z"
---

# Nuxt 4 Reference

## File-Based Routing

Nuxt automatically creates routes based on files in `app/pages/`:

```
pages/
├── index.vue           → /
├── login.vue           → /login
├── users/
│   ├── index.vue       → /users
│   └── [id].vue        → /users/:id
├── duty-days.vue       → /duty-days
├── coverage.vue        → /coverage
├── stipends/
│   ├── index.vue       → /stipends
│   └── [id].vue        → /stipends/:id
├── reports.vue         → /reports
└── settings.vue        → /settings
```

**Dynamic parameters:** Use `[param].vue` syntax. Access via `useRoute().params.param`.

**Catch-all routes:** Use `[...slug].vue` for wildcard matching.

**No manual router configuration needed.**

## Auto-Imports

Nuxt auto-imports Vue, Nuxt, and composable functions. No need to manually import:

```typescript
// ❌ Don't do this
import { ref, computed, watch } from 'vue'
import { useRoute, navigateTo } from 'nuxt/app'
import { useAuth } from '~/composables/useAuth'

// ✅ Do this (auto-imported)
const count = ref(0)
const doubled = computed(() => count.value * 2)
const route = useRoute()
const { currentUser } = useAuth()
```

**Auto-imported:**
- All Vue APIs (`ref`, `computed`, `watch`, `onMounted`, etc.)
- All Nuxt composables (`useRoute`, `useRouter`, `navigateTo`, `useFetch`, `useAsyncData`)
- All composables in `app/composables/` (must use `use` prefix)
- All components in `app/components/` (PascalCase)

## Composables Pattern

Create reusable logic in `app/composables/`. Must start with `use` prefix:

```typescript
// composables/useAuth.ts
export function useAuth() {
  const { currentUser } = useCurrentUser() // VueFire composable
  const db = useFirestore()
  const settingsRef = doc(db, 'app_settings', 'config')
  const settings = useDocument(settingsRef)

  const isAdmin = computed(() => {
    if (!currentUser.value || !settings.value) return false
    const adminUserIds = settings.value.adminUserIds || []
    return adminUserIds.includes(currentUser.value.uid)
  })

  async function login(email: string, password: string) {
    const auth = useFirebaseAuth()
    await signInWithEmailAndPassword(auth, email, password)
  }

  async function logout() {
    const auth = useFirebaseAuth()
    await signOut(auth)
    navigateTo('/login')
  }

  return {
    currentUser,
    isAdmin,
    loading: computed(() => settings.pending),
    login,
    logout
  }
}
```

**Usage in components:**
```vue
<script setup lang="ts">
const { currentUser, isAdmin, login, logout } = useAuth()
</script>
```

## Middleware

### Global Middleware

Runs on every route navigation:

```typescript
// middleware/auth.global.ts
export default defineNuxtRouteMiddleware((to, from) => {
  const { currentUser } = useCurrentUser()
  const publicRoutes = ['/login']

  if (!currentUser.value && !publicRoutes.includes(to.path)) {
    return navigateTo(`/login?redirect=${to.fullPath}`)
  }
})
```

**File naming:** `.global.ts` suffix makes it run on all routes.

### Route-Specific Middleware

Applied to individual pages via `definePageMeta`:

```vue
<!-- pages/admin.vue -->
<script setup lang="ts">
definePageMeta({
  middleware: ['admin-only']
})
</script>
```

```typescript
// middleware/admin-only.ts
export default defineNuxtRouteMiddleware(() => {
  const { isAdmin } = useAuth()
  if (!isAdmin.value) {
    return navigateTo('/unauthorized')
  }
})
```

## Server Routes (API)

Server routes in `server/api/` handle backend logic:

```
server/
├── api/
│   ├── auth/
│   │   └── verify.post.ts       → POST /api/auth/verify
│   ├── users/
│   │   ├── index.get.ts         → GET /api/users
│   │   └── [id]/
│   │       └── update.post.ts   → POST /api/users/:id/update
│   └── stipends/
│       ├── qualifying.get.ts    → GET /api/stipends/qualifying
│       └── process.post.ts      → POST /api/stipends/process
```

**Method suffix:** `.get.ts`, `.post.ts`, `.patch.ts`, `.delete.ts`

**Example:**
```typescript
// server/api/users/[id]/update.post.ts
export default defineEventHandler(async (event) => {
  const id = getRouterParam(event, 'id')
  const body = await readBody(event)

  // Verify admin access
  await verifyAdmin(event)

  // Update Firestore
  await adminDb.doc(`users/${id}`).update(body)

  return { success: true }
})
```

**Request helpers:**
- `readBody(event)` - parse JSON body
- `getQuery(event)` - get query params
- `getRouterParam(event, 'id')` - get route param
- `event.headers.get('authorization')` - get header

**Response:**
- Return object/array - auto-serialized as JSON
- `throw createError({ statusCode: 404, message: 'Not found' })` - error response

## useFetch vs useAsyncData

### useFetch (Recommended)

For HTTP requests to your API routes or external APIs:

```typescript
const { data, pending, error, refresh } = await useFetch('/api/users', {
  query: { role: 'chaplain' }
})
```

**Features:**
- Automatically deduplicates requests
- Server-side rendering on initial load
- Client-side hydration after SSR
- Reactive: re-runs on query param changes
- TypeScript inference for response type

### useAsyncData

For custom async logic (e.g., Firestore queries):

```typescript
const { data, pending, error, refresh } = await useAsyncData('users', async () => {
  const usersQuery = query(collection(db, 'users'))
  const snapshot = await getDocs(usersQuery)
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))
})
```

**Key difference:** `useFetch` is for HTTP, `useAsyncData` is for any async function.

**For COMPASS:** Use VueFire's `useCollection` and `useDocument` for Firestore instead of `useAsyncData`.

## Server-Side vs Client-Side

### Server-Side (SSR)
Runs on the Vercel serverless function during initial page load. Has access to:
- Environment variables (including server-only secrets)
- Firebase Admin SDK
- Server utilities (auth verification)

```typescript
// server/api/stipends/process.post.ts
export default defineEventHandler(async (event) => {
  // This runs on the server
  const token = event.headers.get('authorization')
  const decodedToken = await adminAuth.verifyIdToken(token)
  // Can access NUXT_FIREBASE_ADMIN_SERVICE_ACCOUNT env var
})
```

### Client-Side (SPA)
Runs in the browser after hydration. Has access to:
- Firebase Client SDK
- Firestore real-time listeners
- User interactions

```vue
<script setup lang="ts">
// This runs in the browser
const db = useFirestore()
const usersRef = collection(db, 'users')
const users = useCollection(usersRef)

// Real-time listener attaches here
</script>
```

### Hybrid (Universal)
Composables and utilities can run on both server and client. Check context:

```typescript
export function useAuth() {
  const { currentUser } = useCurrentUser()

  // Only access window/document on client
  if (process.client) {
    console.log('Running in browser')
  }

  // Only access server utilities on server
  if (process.server) {
    console.log('Running on Vercel function')
  }

  return { currentUser }
}
```

## VueFire Integration

VueFire provides reactive Firestore bindings:

### useDocument (Single Document)
```typescript
const db = useFirestore()
const userRef = doc(db, 'users', userId)
const user = useDocument(userRef)

// user.value is reactive
// user.pending is loading state
// user.error is error state
// Listener auto-attaches on mount, detaches on unmount
```

### useCollection (Query)
```typescript
const db = useFirestore()
const usersQuery = query(
  collection(db, 'users'),
  where('isChaplain', '==', true),
  orderBy('displayName')
)
const users = useCollection(usersQuery)

// users.value is reactive array
// Auto-updates when Firestore changes
```

### Why VueFire?
- No manual listener management
- Automatic cleanup on component unmount
- Reactive data binding (Vue `ref` wrapper)
- SSR-compatible (server fetches initial data, client attaches listeners after hydration)

## Deployment to Vercel

### Automatic Deployment

1. Push to GitHub
2. Connect repo to Vercel
3. Vercel auto-detects Nuxt and builds with `nuxt build`
4. Deploys to Vercel Edge + serverless functions

### Build Output

```
.output/
├── public/            # Static assets
├── server/            # Serverless functions
│   ├── index.mjs      # Nuxt server entry
│   └── chunks/        # SSR chunks
└── nitro.json         # Nitro config
```

### Environment Variables

Set in Vercel dashboard or via Vercel CLI:

```bash
vercel env add NUXT_PUBLIC_FIREBASE_API_KEY production
vercel env add NUXT_FIREBASE_ADMIN_SERVICE_ACCOUNT production
```

**Public env vars** (NUXT_PUBLIC_*): Exposed to client bundle
**Server-only env vars** (NUXT_*): Only available in server routes

### Preview Deployments

Every PR gets a preview URL:
- `compass-pr-42.vercel.app`
- Shares production Firestore (use a staging Firebase project if needed)

## Common Gotchas

### 1. Auto-Import Conflicts

If a composable name conflicts with a Vue API, import explicitly:

```typescript
// composables/useWatch.ts conflicts with Vue's watch
import { useWatch } from '~/composables/useWatch'
```

### 2. SSR Hydration Mismatches

If server renders different content than client:
```vue
<template>
  <!-- ❌ Will cause hydration mismatch -->
  <div>{{ new Date().toISOString() }}</div>

  <!-- ✅ Use ClientOnly for client-specific content -->
  <ClientOnly>
    <div>{{ new Date().toISOString() }}</div>
  </ClientOnly>
</template>
```

### 3. Middleware Return Values

Middleware must return `navigateTo()` or `undefined`:

```typescript
// ❌ Wrong
export default defineNuxtRouteMiddleware(() => {
  if (!isAdmin) {
    navigateTo('/login') // Not returned!
  }
})

// ✅ Correct
export default defineNuxtRouteMiddleware(() => {
  if (!isAdmin) {
    return navigateTo('/login')
  }
})
```

### 4. VueFire Pending State

`useDocument` and `useCollection` have a `pending` property, not `loading`:

```typescript
const user = useDocument(userRef)

// ❌ Wrong
if (user.loading) { ... }

// ✅ Correct
if (user.pending) { ... }
```

### 5. Server Route Errors

Use `createError` to return proper HTTP error responses:

```typescript
// ❌ Wrong (returns 200 with error object)
export default defineEventHandler(async (event) => {
  return { error: 'Not found' }
})

// ✅ Correct (returns 404 status)
export default defineEventHandler(async (event) => {
  throw createError({ statusCode: 404, message: 'Not found' })
})
```

## Performance Tips

### 1. Code Splitting

Pages are automatically code-split. Heavy components can be lazy-loaded:

```vue
<script setup lang="ts">
const HeavyChart = defineAsyncComponent(() =>
  import('~/components/HeavyChart.vue')
)
</script>
```

### 2. Prefetching

`<NuxtLink>` automatically prefetches linked pages on hover:

```vue
<NuxtLink to="/users">Users</NuxtLink>
<!-- /users route prefetched on hover -->
```

Disable if not needed:
```vue
<NuxtLink to="/users" :prefetch="false">Users</NuxtLink>
```

### 3. Server Route Caching

Cache API responses with `defineCachedEventHandler`:

```typescript
export default defineCachedEventHandler(async (event) => {
  // Cached for 60 seconds
  const users = await fetchUsers()
  return users
}, {
  maxAge: 60
})
```

**For COMPASS:** Don't cache dashboard KPIs (they need real-time updates).

## Debugging

### Server Logs

Server route logs appear in Vercel function logs:

```typescript
export default defineEventHandler(async (event) => {
  console.log('Processing stipend...', event.context)
  // Logs appear in Vercel dashboard → Functions → Logs
})
```

### Client Console

Client-side logs appear in browser DevTools:

```typescript
const { data } = await useFetch('/api/users')
console.log('Users loaded:', data.value)
```

### Vue DevTools

Install Vue DevTools browser extension for:
- Component inspector
- Vuex/Pinia state
- Route navigation history
- Performance profiling

## Further Reading

- Nuxt Docs: https://nuxt.com/docs
- VueFire Docs: https://vuefire.vuejs.org/
- Nitro (Nuxt server engine): https://nitro.unjs.io/
